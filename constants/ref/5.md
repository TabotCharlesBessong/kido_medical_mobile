Sure, let's go step by step to create a slice for handling doctor's available time slots, including actions to fetch, create, and update time slots. We will also implement screens to display and manage these time slots.

### Step 1: Define Types

First, define the types for the time slots.

```typescript
// types.ts
export interface TimeSlot {
  id?: number;
  doctorId: number;
  startTime: string;
  endTime: string;
  isAvailable: boolean;
}

export interface TimeSlotState {
  timeSlots: TimeSlot[];
  loading: boolean;
  error: string | null;
}
```

### Step 2: Create Time Slot Slice

Create the slice to handle CRUD operations for time slots.

```typescript
// timeSlotSlice.ts
import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import axiosInstance from '@/services/axiosInstance';
import { TimeSlot, TimeSlotState } from '@/constants/types';

const initialState: TimeSlotState = {
  timeSlots: [],
  loading: false,
  error: null,
};

export const fetchTimeSlots = createAsyncThunk(
  'timeSlot/fetchTimeSlots',
  async (doctorId: number, { rejectWithValue }) => {
    try {
      const response = await axiosInstance.get(`/doctor/${doctorId}/timeslots`);

      if (response.data.success === false) {
        return rejectWithValue(response.data.message);
      }

      return response.data.timeSlots;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

export const createTimeSlot = createAsyncThunk(
  'timeSlot/createTimeSlot',
  async (timeSlotData: TimeSlot, { rejectWithValue }) => {
    try {
      const response = await axiosInstance.post('/doctor/create-time-slot', timeSlotData);

      if (response.data.success === false) {
        return rejectWithValue(response.data.message);
      }

      return response.data.timeSlot;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

export const updateTimeSlot = createAsyncThunk(
  'timeSlot/updateTimeSlot',
  async (timeSlotData: TimeSlot, { rejectWithValue }) => {
    try {
      const { id, ...updateData } = timeSlotData;
      const response = await axiosInstance.put(`/timeslots/${id}`, updateData);

      if (response.data.success === false) {
        return rejectWithValue(response.data.message);
      }

      return response.data.timeSlot;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.message || error.message);
    }
  }
);

const timeSlotSlice = createSlice({
  name: 'timeSlot',
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(fetchTimeSlots.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchTimeSlots.fulfilled, (state, action: PayloadAction<TimeSlot[]>) => {
        state.loading = false;
        state.timeSlots = action.payload;
      })
      .addCase(fetchTimeSlots.rejected, (state, action: PayloadAction<any>) => {
        state.loading = false;
        state.error = action.payload || 'An error occurred';
      })
      .addCase(createTimeSlot.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(createTimeSlot.fulfilled, (state, action: PayloadAction<TimeSlot>) => {
        state.loading = false;
        state.timeSlots.push(action.payload);
      })
      .addCase(createTimeSlot.rejected, (state, action: PayloadAction<any>) => {
        state.loading = false;
        state.error = action.payload || 'An error occurred';
      })
      .addCase(updateTimeSlot.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateTimeSlot.fulfilled, (state, action: PayloadAction<TimeSlot>) => {
        state.loading = false;
        const index = state.timeSlots.findIndex(slot => slot.id === action.payload.id);
        if (index !== -1) {
          state.timeSlots[index] = action.payload;
        }
      })
      .addCase(updateTimeSlot.rejected, (state, action: PayloadAction<any>) => {
        state.loading = false;
        state.error = action.payload || 'An error occurred';
      });
  },
});

export default timeSlotSlice.reducer;
```

### Step 3: Implement Screens

#### Display Time Slots

```typescript
// TimeSlotsScreen.tsx
import React, { useEffect } from 'react';
import { View, Text, StyleSheet, FlatList, Button } from 'react-native';
import { useSelector, useDispatch } from 'react-redux';
import { fetchTimeSlots } from '@/store/slices/timeSlotSlice';
import { RootState, AppDispatch } from '@/store';
import { useRouter } from 'expo-router';

const TimeSlotsScreen: React.FC = () => {
  const dispatch: AppDispatch = useDispatch();
  const { timeSlots, loading, error } = useSelector((state: RootState) => state.timeSlot);
  const router = useRouter();

  useEffect(() => {
    const doctorId = 1; // Replace with actual doctor ID
    dispatch(fetchTimeSlots(doctorId));
  }, [dispatch]);

  return (
    <View style={styles.container}>
      {loading && <Text>Loading...</Text>}
      {error && <Text style={styles.errorText}>{error}</Text>}
      <FlatList
        data={timeSlots}
        keyExtractor={(item) => item.id?.toString() || ''}
        renderItem={({ item }) => (
          <View style={styles.timeSlot}>
            <Text>Start: {item.startTime}</Text>
            <Text>End: {item.endTime}</Text>
            <Text>Available: {item.isAvailable ? 'Yes' : 'No'}</Text>
          </View>
        )}
      />
      <Button title="Create New Time Slot" onPress={() => router.push('/CreateTimeSlot')} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  timeSlot: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  errorText: {
    color: 'red',
    marginTop: 10,
    textAlign: 'center',
  },
});

export default TimeSlotsScreen;
```

#### Create and Update Time Slots

```typescript
// CreateTimeSlotScreen.tsx
import React, { useState } from 'react';
import { View, StyleSheet, Button, Text } from 'react-native';
import { useFormik } from 'formik';
import * as yup from 'yup';
import DateTimePicker from '@react-native-community/datetimepicker';
import { useDispatch } from 'react-redux';
import { createTimeSlot } from '@/store/slices/timeSlotSlice';
import { AppDispatch } from '@/store';
import { useRouter } from 'expo-router';

const CreateTimeSlotScreen: React.FC = () => {
  const [startTime, setStartTime] = useState<Date | null>(null);
  const [endTime, setEndTime] = useState<Date | null>(null);
  const [showStartTimePicker, setShowStartTimePicker] = useState(false);
  const [showEndTimePicker, setShowEndTimePicker] = useState(false);
  const dispatch: AppDispatch = useDispatch();
  const router = useRouter();

  const validationSchema = yup.object({
    startTime: yup.date().required('Start time is required'),
    endTime: yup.date().required('End time is required'),
  });

  const formik = useFormik({
    initialValues: {
      startTime: '',
      endTime: '',
    },
    validationSchema,
    onSubmit: async (values) => {
      const doctorId = 1; // Replace with actual doctor ID
      const newTimeSlot = {
        doctorId,
        startTime: values.startTime,
        endTime: values.endTime,
        isAvailable: true,
      };
      await dispatch(createTimeSlot(newTimeSlot));
      router.push('/TimeSlotsScreen');
    },
  });

  const handleStartTimeChange = (event: any, selectedDate: Date | undefined) => {
    setShowStartTimePicker(false);
    if (selectedDate) {
      setStartTime(selectedDate);
      formik.setFieldValue('startTime', selectedDate.toISOString());
    }
  };

  const handleEndTimeChange = (event: any, selectedDate: Date | undefined) => {
    setShowEndTimePicker(false);
    if (selectedDate) {
      setEndTime(selectedDate);
      formik.setFieldValue('endTime', selectedDate.toISOString());
    }
  };

  return (
    <View style={styles.container}>
      <Button title="Select Start Time" onPress={() => setShowStartTimePicker(true)} />
      {showStartTimePicker && (
        <DateTimePicker
          value={startTime || new Date()}
          mode="time"
          display="default"
          onChange={handleStartTimeChange}
        />
      )}
      <Text>{startTime?.toISOString()}</Text>
      {formik.touched.startTime && formik.errors.startTime && (
        <Text style={styles.errorText}>{formik.errors.startTime}</Text>
      )}

     

 <Button title="Select End Time" onPress={() => setShowEndTimePicker(true)} />
      {showEndTimePicker && (
        <DateTimePicker
          value={endTime || new Date()}
          mode="time"
          display="default"
          onChange={handleEndTimeChange}
        />
      )}
      <Text>{endTime?.toISOString()}</Text>
      {formik.touched.endTime && formik.errors.endTime && (
        <Text style={styles.errorText}>{formik.errors.endTime}</Text>
      )}

      <Button title="Submit" onPress={formik.handleSubmit as any} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
  errorText: {
    color: 'red',
    marginTop: 10,
    textAlign: 'center',
  },
});

export default CreateTimeSlotScreen;
```

### Explanation

- **Types**: Defined types for `TimeSlot` and `TimeSlotState`.
- **Thunk Actions**: Added actions to fetch, create, and update time slots.
- **Time Slot Slice**: Handled the state management for time slots.
- **Screens**: 
  - `TimeSlotsScreen` displays all time slots.
  - `CreateTimeSlotScreen` allows creating new time slots using a date-time picker.

This setup allows you to manage time slots for doctors, including creating, fetching, and updating them, while managing the state using Redux and handling asynchronous operations with Redux Toolkit's `createAsyncThunk`.