Certainly! Here's a comprehensive guide including the `doctorSlice` for handling doctor functionalities, and examples of how to use this slice in the respective screens.

### Step 1: Create the `doctorSlice`

```typescript
// doctor.slice.ts
import { createSlice, createAsyncThunk } from "@reduxjs/toolkit";
import axios from "axios";
import { DoctorCardProps } from "@/constants/types";

interface DoctorState {
  doctors: DoctorCardProps[];
  doctorDetails: DoctorCardProps | null;
  loading: boolean;
  error: string | null;
}

const initialState: DoctorState = {
  doctors: [],
  doctorDetails: null,
  loading: false,
  error: null,
};

// Async actions for CRUD operations
export const registerDoctor = createAsyncThunk(
  "doctor/registerDoctor",
  async (doctorData: DoctorCardProps, { rejectWithValue }) => {
    try {
      const response = await axios.post("http://192.168.1.199:5001/api/doctor/register", doctorData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

export const updateDoctor = createAsyncThunk(
  "doctor/updateDoctor",
  async (doctorData: DoctorCardProps, { rejectWithValue }) => {
    try {
      const response = await axios.put(`http://192.168.1.199:5001/api/doctor/${doctorData.id}`, doctorData);
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

export const fetchDoctors = createAsyncThunk(
  "doctor/fetchDoctors",
  async (_, { rejectWithValue }) => {
    try {
      const response = await axios.get("http://192.168.1.199:5001/api/doctors");
      return response.data;
    } catch (error) {
      return rejectWithValue(error.response.data);
    }
  }
);

const doctorSlice = createSlice({
  name: "doctor",
  initialState,
  reducers: {},
  extraReducers: (builder) => {
    builder
      .addCase(registerDoctor.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(registerDoctor.fulfilled, (state, action) => {
        state.doctorDetails = action.payload;
        state.loading = false;
        state.error = null;
      })
      .addCase(registerDoctor.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(updateDoctor.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(updateDoctor.fulfilled, (state, action) => {
        state.doctorDetails = action.payload;
        state.loading = false;
        state.error = null;
      })
      .addCase(updateDoctor.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      })
      .addCase(fetchDoctors.pending, (state) => {
        state.loading = true;
        state.error = null;
      })
      .addCase(fetchDoctors.fulfilled, (state, action) => {
        state.doctors = action.payload;
        state.loading = false;
        state.error = null;
      })
      .addCase(fetchDoctors.rejected, (state, action) => {
        state.loading = false;
        state.error = action.payload as string;
      });
  },
});

export default doctorSlice.reducer;
```

### Step 2: Setup the Redux Store

Make sure you have your Redux store set up to include the `doctorSlice`.

```typescript
// store.ts
import { configureStore } from "@reduxjs/toolkit";
import authReducer from "@/store/slices/auth.slice";
import doctorReducer from "@/store/slices/doctor.slice";

const store = configureStore({
  reducer: {
    auth: authReducer,
    doctor: doctorReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store;
```

### Step 3: Doctor Registration Screen

Here's an example of how you can implement the doctor registration screen.

```typescript
// DoctorRegistration.tsx
import React from "react";
import { useDispatch, useSelector } from "react-redux";
import { Formik, FormikHelpers } from "formik";
import * as yup from "yup";
import { View, Button, Text } from "react-native";
import { RootState, AppDispatch } from "@/store/store";
import { registerDoctor } from "@/store/slices/doctor.slice";
import { DoctorCardProps } from "@/constants/types";
import { AuthInputField } from "@/components"; // Assuming AuthInputField component is available

const doctorRegistrationSchema = yup.object({
  name: yup.string().required("Name is required"),
  speciality: yup.string().required("Speciality is required"),
  location: yup.string().required("Location is required"),
  experience: yup.number().required("Experience is required").min(0, "Experience must be a positive number"),
  language: yup.string().required("Language is required"),
  fee: yup.number().required("Fee is required").min(0, "Fee must be a positive number"),
});

const DoctorRegistration = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { loading, error } = useSelector((state: RootState) => state.doctor);

  const initialValues: DoctorCardProps = {
    image: "",
    name: "",
    rating: 0,
    location: "",
    experience: 0,
    speciality: "",
    language: "",
    fee: 0,
  };

  const handleSubmit = async (values: DoctorCardProps, actions: FormikHelpers<DoctorCardProps>) => {
    await dispatch(registerDoctor(values));
  };

  return (
    <Formik initialValues={initialValues} validationSchema={doctorRegistrationSchema} onSubmit={handleSubmit}>
      {({ handleSubmit }) => (
        <View>
          <AuthInputField name="name" placeholder="Name" label="Name" />
          <AuthInputField name="speciality" placeholder="Speciality" label="Speciality" />
          <AuthInputField name="location" placeholder="Location" label="Location" />
          <AuthInputField name="experience" placeholder="Experience" label="Experience" keyboardType="numeric" />
          <AuthInputField name="language" placeholder="Language" label="Language" />
          <AuthInputField name="fee" placeholder="Fee" label="Fee" keyboardType="numeric" />
          <Button title="Register" onPress={handleSubmit} disabled={loading} />
          {loading && <Text>Loading...</Text>}
          {error && <Text>{error}</Text>}
        </View>
      )}
    </Formik>
  );
};

export default DoctorRegistration;
```

### Step 4: Fetch Doctors Screen

Here's an example of how you can implement a screen to fetch and display doctors.

```typescript
// DoctorsList.tsx
import React, { useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import { View, Text, FlatList } from "react-native";
import { RootState, AppDispatch } from "@/store/store";
import { fetchDoctors } from "@/store/slices/doctor.slice";

const DoctorsList = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { doctors, loading, error } = useSelector((state: RootState) => state.doctor);

  useEffect(() => {
    dispatch(fetchDoctors());
  }, [dispatch]);

  return (
    <View>
      {loading && <Text>Loading...</Text>}
      {error && <Text>{error}</Text>}
      <FlatList
        data={doctors}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View>
            <Text>{item.name}</Text>
            <Text>{item.speciality}</Text>
            <Text>{item.location}</Text>
          </View>
        )}
      />
    </View>
  );
};

export default DoctorsList;
```

### Step 5: Update Doctor Information Screen

Here's an example of how you can implement a screen to update doctor information.

```typescript
// UpdateDoctor.tsx
import React from "react";
import { useDispatch, useSelector } from "react-redux";
import { Formik, FormikHelpers } from "formik";
import * as yup from "yup";
import { View, Button, Text } from "react-native";
import { RootState, AppDispatch } from "@/store/store";
import { updateDoctor } from "@/store/slices/doctor.slice";
import { DoctorCardProps } from "@/constants/types";
import { AuthInputField } from "@/components"; // Assuming AuthInputField component is available

const updateDoctorSchema = yup.object({
  name: yup.string().required("Name is required"),
  speciality: yup.string().required("Speciality is required"),
  location: yup.string().required("Location is required"),
  experience: yup.number().required("Experience is required").min(0, "Experience must be a positive number"),
  language: yup.string().required("Language is required"),
  fee: yup.number().required("Fee is required").min(0, "Fee must be a positive number"),
});

const UpdateDoctor = () => {
  const dispatch = useDispatch<AppDispatch>();
  const { loading, error, doctorDetails } = useSelector((state: RootState) => state.doctor);

  const initialValues: DoctorCardProps = doctorDetails || {
    image: "",
    name: "",
    rating: 0,
    location:

 "",
    experience: 0,
    speciality: "",
    language: "",
    fee: 0,
  };

  const handleSubmit = async (values: DoctorCardProps, actions: FormikHelpers<DoctorCardProps>) => {
    await dispatch(updateDoctor(values));
  };

  return (
    <Formik initialValues={initialValues} validationSchema={updateDoctorSchema} onSubmit={handleSubmit} enableReinitialize>
      {({ handleSubmit }) => (
        <View>
          <AuthInputField name="name" placeholder="Name" label="Name" />
          <AuthInputField name="speciality" placeholder="Speciality" label="Speciality" />
          <AuthInputField name="location" placeholder="Location" label="Location" />
          <AuthInputField name="experience" placeholder="Experience" label="Experience" keyboardType="numeric" />
          <AuthInputField name="language" placeholder="Language" label="Language" />
          <AuthInputField name="fee" placeholder="Fee" label="Fee" keyboardType="numeric" />
          <Button title="Update" onPress={handleSubmit} disabled={loading} />
          {loading && <Text>Loading...</Text>}
          {error && <Text>{error}</Text>}
        </View>
      )}
    </Formik>
  );
};

export default UpdateDoctor;
```

### Step 6: Integration with Navigation

Ensure you integrate these screens into your navigation setup. Hereâ€™s a basic example using React Navigation:

```typescript
// App.tsx
import React from "react";
import { NavigationContainer } from "@react-navigation/native";
import { createStackNavigator } from "@react-navigation/stack";
import { Provider } from "react-redux";
import store from "@/store/store";
import DoctorRegistration from "@/screens/DoctorRegistration";
import DoctorsList from "@/screens/DoctorsList";
import UpdateDoctor from "@/screens/UpdateDoctor";

const Stack = createStackNavigator();

const App = () => {
  return (
    <Provider store={store}>
      <NavigationContainer>
        <Stack.Navigator>
          <Stack.Screen name="Doctor Registration" component={DoctorRegistration} />
          <Stack.Screen name="Doctors List" component={DoctorsList} />
          <Stack.Screen name="Update Doctor" component={UpdateDoctor} />
        </Stack.Navigator>
      </NavigationContainer>
    </Provider>
  );
};

export default App;
```

This complete setup includes the `doctorSlice`, screens for doctor registration, fetching doctors, and updating doctor information, and integrates these screens into a basic navigation flow. You can extend this approach to include other functionalities like managing timeslots, consultations, vital signs, prescriptions, and treatments. Let me know if you need further assistance with those!